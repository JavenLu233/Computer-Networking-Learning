# 计算机网络

# 计算机网络

b站中科大计算机网络课程：https://www.bilibili.com/video/BV1JV411t7ow

所用书籍：《计算机网络（自顶向下方法 第7版）》

本书网站：https://wps.pearsoned.com/ecs_kurose_compnetw_6/216/55463/14198700.cw/index.html

---


## 前述

b（bit）是比特，B（Byte）是字节

1kb=1000bits，1KB = 1024KB ~= 8000bits

流量使用bps作为单位，十进制算

---

计算机网络TOP10问题：

1. 可靠数据传输原理
2. 拥塞控制

  

## 第一章 计算机网络概论

这一章十分重要！！了解基本术语和概念以及基本原理，搭建起一个框架！


### 什么是Internet

网络 -> 计算机网络 -> 互联网

网络是节点和边之间的关系,与大小形状无关

  


#### 计算机网络

**节点:**

* 主机节点(电脑,手机,冰箱等) 是源节点(方形)

* 数据交换节点(中继器,路由器,交换机等) 是交换节点(圆形)


**链路:** 把节点连接在一起

* 接入网链路(access): 以太网的网线, 主机节点和数据交换节点连接在一起
* 主干链路(backbone) : 将数据交换节点连接在一起


**协议:**支撑互联网工作的标准

* 物理层
* 链路层
* 网络层: RIP
* 传输层: TCP, UDP

  


#### 互联网

*内部网(intranet*)

什么是互联网(Internet): 

两种方式描述

①构成互联网基本硬件和软件组件

②分布式的应用进程 及 为分布式应用进程提供的基础设施(应用层以下的)


**具体构成描述**

端系统(end system/host) : 硬件, 主机, 操作系统, 网络应用   用方形表示

分组交换机(packet switch): link-layer switch链路层交换机, router路由器  用圆形 表示

分组(packet) : 一台端系统向另一台端系统发送数据时,发送端系统将数据分段,并为每段加上首部字节.

通信链路(link) :	带宽(bandwidth): 以bps(bit per second)作为指标

端系统通过通信链路和分组交换机连接到一起


端系统通过 因特网服务提供商 Internet Service Provider, ISP 接入因特网

每个ISP是一个由多个分组交换机和多端通信链路组成的网络

  

**协议**: 对等层的实体(peer entity) 在通讯过程中遵循的规则的集合

互联网两个重要的协议:

* TCP(Transmission Control Protocol, 传输控制协议)
* IP(Internet Protocol, 网际协议): 定义了在路由器和端系统之间发送和接受的分组格式


PDU(Protocol Data Unit): 协议数据单元


协议定义了:

* 格式: 包括语法和语义

* 次序

* 动作: 收到请求报文后内部处理的操作


Internet标准: 

RFC: Request for comments 请求评论

IETF: Internet Engineering Task Force

互联网所有标准以RFC文档形式在IETF网站上发布,由全球工程师共同构建

  

**服务描述**

分布式应用程序(distributed application): 涉及堕胎相互交换数据的端系统,且运行在端系统上, 如电子邮件, Web冲浪, 即时讯息, 社交网络, IP语音, 流式视频, 分布式游戏, P2P文件共享等等.

互联网就是应用程序的平台


应用程序编程接口(Application Programming Interface, API)

因特网API是一套发送软件必须遵循的规则集合

  


### 网络边缘

网络边缘(Internet edge): 主机, 应用程序(客户端和服务器)


**C/S模式(Client and Server, 客户端/服务器模式):**

*如:Web浏览器/服务器, email客户端/服务器*

客户端主动请求服务器的资源

服务器先运行, 客户端后运行

服务器农场(Server Farm): 数千台服务器

主要问题: 可扩展性不强, 效率但达到一定规模会断崖式下降

  

**P2P模式(Peer to Peer, 对等体):**

*如: 迅雷, 电驴等分布式文件分发系统*

每个节点既是客户端也是服务器，用户数量增多后资源节点也会变多，下载速度比传统FTP速度快。


**TCP（Transmission Control Protocol）：**

应用：HTTP（Web），FTP（文件传送），Telnet（远程登陆），SMTP（email）

通信之前首先建立连接（握手），然后两个通信主机和底层协议站做好准备进行数据传输

面向连接，可靠的（Reliable Data Transfer），保序的（不错误，不丢失，不重复，不乱序）

考虑接收方和网络路径通行能力，具有特性：拥塞控制（congestion control）


**UDP（User Datagram Protocol）：**

应用：流媒体，远程会议，DNS，Internet电话

无连接，不可靠，无流量控制，无拥塞控制，但是速度快

  

### 网络核心

网络核心(Internet core): 互连的路由器, 网络的网络

瞬时的切换开关,达到数据交换的作用


两种方式：

#### 电路交换（circuit switching）

为每个呼叫预留一条专有电路，如：电话网

独享资源：不共享，因此呼叫一旦建立就能够保证性能

如果呼叫没有数据发送，被分配的资源就会被浪费（no sharing）


线路被分为片（pieces），有以下方式：

频分（FDM）

时分（TDM）

![image](assets/image-20220801161201-9mbr2w3.png)

波分（WDM） *光纤*


不适合计算机之间的通信：

* 连接建立时间长
* 计算机之间的通信有突发性，如果使用线路交换，则浪费的片比较多
* 可靠性不高（？）


#### 分组交换（packet switching）

传播时延，处理时延，排队时延，但是具有共享性

  

过程：

* 将要传送的数据分成一个个单位：分组（packet）
* 将分组从一个路由器传到相邻路由器（hop），每个节点都要存储再转发，一段段最终从源端传到目标端
* 每段：采用链路的最大传输能力（带宽）


如果到达速率大于链路的输出速率：

* 分组将会排队，等待传输

* 如果路由器的缓存用完了，分组将会被抛弃


网络核心的关键功能：

路由：通过算法，决定分组采用的源到目标的路径

转发：将分组从路由器的输入链路转移到输出链路


统计多路复用：特殊的时分，并不是固定某个时间段给某个用户使用


分组交换允许更多的用户使用网络！


分组交换的两种方式：

* 数据报（datagram）网络：源主机和目标主机不用先握手，携带目标主机的完整地址

  * 通信之前无需建立起一个连接，有数据就传输
  * 每一个分组都独立路由（路径不一样，可能会失序）
  * 路由器根据分组的目标地址进行路由


* 虚电路（virtual circuit）网络：源主机和目标主机通讯前握手，建立链路，每个分组携带虚电路号

  

### 接入网和物理媒体

网络接入(access): 有线或无线的通信链路


住宅接入：（modem）

利用电话线，通过音频约定规则传输数据（调制解调：调频，调幅，调相位，综合调制）

在音频的载波（0-4kHz）上上网，即冲浪。

存在的问题：

* 不能同时上网和打电话，不能总是在线

* 带宽低于56Kbps


接入网（digital subscriber line， DSL 数字用户线）：

同样利用电话线，但是上行和下行的带宽不同，下行带宽更大

HFC（hybrid fiber coax）： 非对称：最高30Mbps下行传输效率，2Mbps上行传输效率

各用户共享到线缆头端的接入网络


企业接入网络（Ethernet）：

端系统通常直接镰刀以太网络交换机上，各层次的交换机连接


无线接入网络：

无线WLANs：

建筑物内部，WiFi

广域无线接入：

电信运营商提供的3G，4G

  

物理媒体：

Bit：在发送-接受对间传播

物理链路：连接每个发送-接受对之间的物理媒体

导引媒体：信号沿者固体媒介被导引：同轴电缆，光纤，双绞线

非导引媒体：开放的空间传输电磁波或者光信号，在电磁或者光信号中承载数字数据

相同情况下，导引媒体传输的更远。


常见的导体介质：

双绞线：两个绝缘铜导线拧合： 5类：100Mbps以太网，6类：10Gbps

同轴电缆：两根同心的铜导线：双向

光纤和光缆： 高速，低误码率，安全

无线链路：地面微波，LAN（如WiFi），wide-area（如蜂窝），卫星

  

### Internet结构和ISP

ISP:Internet Service Provider

ICP:Internet Content Provider

IXP：Internet exchange point


* 中心：第一层ISP（如UUNet，BBN/Genuity，Sprint，AT&T）

  * 直接与其他第一层ISP相连
  * 与大量第二层ISP和其他客户网络相连
  * 节点少，带宽极大

  

  


### 分组时延、丢包和吞吐量

传输时延与传播时延的比较：

传输时延是带宽的函数，传播时延是两个相邻路由器举例的函数

因此，卫星通信中传播时延不可忽略


#### 分组丢失和时延

在路由器缓冲区的分组队列

* 丢失：分组到达链路的速率超过了链路输出的能力
* 时延：分组等待排到队头/正在被传输


#### 四种分组时延

* 处理延时：（微秒级或更低）

  * 检查bit级差错
  * 检查分组首部和决定将分组导向何处
* 排队延时：（取决于拥塞程度，流量强度）

  * 在输出链路上等待传输的时间
  * 依赖于路由器的拥塞程度
  * 流量强度I = （L*a）/R （a为分组到达队列的平均速率，单位分组/秒，L为分组长度，R为传输速率）

    * I~0：平均排队延时很小
    * I->1：排队延时变得很大
    * I>1:比特到达速度超过队列输出速度，延时趋于无穷大
* 传输延时：（L/R，微秒级到毫秒级）

  * R=链路带宽（bps）
  * L=分组长度（bits）
  * 将分组发送到链路上的时间=L/R
  * 存储转发延时
* 传播延时：（d/s，微秒级到毫秒级）

  * d=物理链路长度
  * s=在媒体上的传播速度（约等于2E8 m/s）
  * 传播延时=d/s


两个路由器之间为一个hop（跳/段）


LAN（局域网）

传播延迟极低，信道容量小（传播路径大时，在一个路径上可以传播很多个分组，则信道容量大）


WAN（广域网）

  

在windows的命令行界面

```CPP
tracert www.xxx.com
```

进行跃点跟踪，每次测试一段，发出三个测试包（通过设置TTL实现每段测时）


#### 分组丢失

* 链路的队列缓冲区有限
* 当分组到达一个满的队列时，该分组会丢失
* 丢失的分组可能会被前一个节点或源端系统重传，或者根本不重传


#### 吞吐量

吞吐量：单位时间内在端源和目标端之间传输的速率

瞬间吞吐量：在一个时间点的速率

平均吞吐量：一个长时间内平均值

瓶颈链路（带宽最小的）决定了平均吞吐量

  

### 协议层次和服务模型


分层：

* 概念化：结构清晰，便于标示网络组件，以及描述其相互关系。
* 结构化：模块化更易于维护和系统升级。


上下层通过接口 使用/提供服务

对等层通过协议 交换信息


服务（service）：低层实体向上层实体提供它们之间的通信的能力

服务用户（service user）

服务提供则（service provider）


原语（primitive）：上层使用下层服务的形式，高层使用低层提供的服务，以及低层向高层提供的服务都是通过服务访问原语来进行交互的      ---形式

*服务用户通过原语告诉服务提供者 将要使用什么服务*

*服务提供者通过原语告诉服务用户 能够提供什么服务*


服务访问点SAP（Services Access Point）：上层使用下层提供的服务通过层间的接口   ---地点

地址（address）：下层的一个实体支撑着上层的多个实体，SAP有标志不同上层实体的作用

例子：传输层的SAP：端口（port）


#### 服务和协议的联系：

* 本层**协议的实现**要依靠下层提供的服务
* 本层实体通过协议为上层**提供更高级的服务**

  

#### 数据单元（DU）

![image](assets/image-20220808161226-vrfxtpk.png)


* 有时候上层的SDU太大，会接收完毕后分解为若干部分并且分别添加头部信息，作为下一层的SDU/本层的PDU

* 上层的SDU太小，则会合在一起并加上头部信息

ICI：接口控制信息


#### Internet协议栈

* 应用层：网络应用（报文message）

  * 为人类用户或者其他应用进程提供网络应用服务
  * FTP，SMTP，HTTP，DNS
* 传输层：主机之间的数据传输（报文段segment）

  * 在网络层提供的端到端通信基础上，细分为进程到进程，将不可靠的通信变成可靠的通信
  * TCP，UDP
* 网络层：为数据报从源到目的选择路由（分组packet/如果是无连接方式：数据报datagram）

  * 主机与主机之间的通信，端到端通信，不可靠
  * IP，路由协议
* 链路层：相邻网络节点间的数据传输（帧frame）

  * 2个梁林2点的通信，点到点通信，可靠或不可靠
  * 点对点协议PPP，802.11（wifi），Ethernet
* 物理层：在线路上传送bit（位bit）

  

ISO/OSI参考模型中，应用层和传输层之间还有两个层次：表示层，会话层

* 表示层：允许应用解释传输的数据

  * 如：加密，压缩，机器相关的表示转换
* 会话层：数据交换的同步，检查点，恢复

  

#### 封装和解封装

![image](assets/image-20220808163842-t2l97hv.png)


源端层层封装（加上多层头部信息），目标端层层解封装

在各个交换机需要进行两层的解封装/封装，各个路由器需要进行三层的解封装/封装

  

  

### 历史

![image](assets/image-20220808164837-b9mbs36.png)

  

### 面对攻击的网络

病毒（virus）：需要用户交互来感染

蠕虫（worm）：不需要用户交互就能感染

僵尸网络（botnet）：受害主机群

拒绝服务攻击（Denial-of-Service（DoS）attack）

* 弱点攻击：发送制作精细的报文
* 带宽洪泛：向目标主机发送大量分组使接入链路拥塞，则合法的分组无法到达服务器
* 链接洪泛：创建大量半开或者全开TCP连接，使主机停止接收合法的连接

分布式Dos（DDoS）：利用僵尸网络发起DoS攻击


分组嗅探器（packet sniffer）：获取分组的副本

IP哄骗（IP spoofing）：将具有虚假源地址的分组注入因特网的能力，以冒充用户

  

  


## 第二章 应用层

### 原理

可能的应用架构：

* 客户-服务器模式（C/S：client/server）
* 对等模式（P2P：Peer To Peer）
* 混合体：客户-服务器和对等体系结构


#### C/S体系结构

服务器：

* 一直在运行
* 固定的IP地址和约定好的端口
* 拓展性：服务器场

  * 数据中心进行拓展
  * 拓展性差（达到一定用户数时服务能力断崖式下降）
* 可靠性差（服务器宕机则无法提供服务）


客户端：

* 主动与服务器通信
* 与互联网间隙性连接
* 可能是动态IP地址
* 不直接与其他客户端通信


#### P2P体系结构

* 几乎没有一直运行的服务器，不需要旁的大的服务器基础设施和带宽
* 任意端系统之间可以进行通信
* 每一个节点既是客户端又是服务器

  * 自拓展性：新peer节点带来新的服务能力，当然也有新的服务请求（客户数量增加时服务能力维持在一定程度，甚至速度更快资源更多，因此可以吸引大量用户）
* 参与的主机间隙性连接且可以改变IP地址（难以管理）


面临的三个主要挑战

* ISP友好：P2P体系结构增加了从服务器到住宅ISP的上载流量，给ISP带来了巨大压力
* 安全性
* 激励用户资源向应用提供带宽、存储和计算资源


#### C/S和P2P体系结构的混合体

如：Napster

* 文件搜索：集中
* 文件传输：P2P


即时通信

* 在线监测：集中
* 两个用户之间聊天：P2P



#### 进程通信

进程：在主机上运行的应用程序

* 同一主机内，利用操作系统定义的通信机制进行通信
* 不同主机，通过交换报文（Message）进行通信

客户端进程：发起通信的进程

服务器进程：等待连接的进程



#### 对进程进行编址（addressing）

进程为了接收报文，必须有一个标识，即SAP

* 主机：唯一的32位IP地址
* 传输层协议：TCP or UDP
* 端口号（Port Number）


一些知名端口号例子：

* Web服务器：80
* 邮件服务器（SMTP协议）：25

* HTTP：TCP 80
* Mail： TCP 80
* ftp： TCP 2


一个进程，用IP+port标示 端结点


#### 穿过传输层需要的信息

层间接口必须携带的信息：

* 传输的报文（对于本层来说的SDU）
* 谁传的：我方应用进程的标示：IP+TCP（UDP）端口号（0~65535，16个比特）
* 传给谁

传输层实体（tcp或者udp的实体），并进行TCP报文段（UDP数据报）的封装

* 源端口，目标端口号，数据等
* 将IP地址往下交IP实体，用于封装IP数据报


如果Socket API 每次传输报文都要携带如此多信息，太繁琐一撮，不便于管理

用代号标示通信的双方或者单方：socket

就像OS打开文件返回的句柄一样，对句柄的操作就是对文件的操作


#### TCP socket

* TCP服务，两个进程通信之前建立连接（因为该通信需要持续一段时间）

* 可以用一个整数表示两个应用实体之间的关系，四元组的**本地**标识（应用层和传输层之间的约定）

* 如此，穿过层间接口的信息量最小，且便于管理

* TCP socket

  * 4元组：源IP，源端口，目标IP，目标端口
  * 唯一指定了一个会话（两个进程之间）
  * 应用使用这个标示，与远程的应用进程通信
  * 不必在每一个报文的发送都指定这个4元组
  * 建立完连接后，只需要传输数据本身和socket

![image](assets/image-20220809210915-lfs9umz.png)




#### UDP socket

UDP服务，两个进程之间通信前无需建立连接

* 每个报文都是独立传输的
* 签后报文可能给不同的分布式进程

因此只用一个整数表示本地应用实体的标示


UDP socket：

* 2元组：本地IP，本地端口（只有**本地意义**，只表示了会话关系的一个端结点）
* 发送数据报时，直接采用本地套接字，不必在每个报文中指明自己的ip和port

* 但是在传输接收报文时，必须提供三个信息，UDP socket，对方IP+对方端口，数据
* 接收报文时，传输层需要上传对方的IP，port    **（？）**



套接字（Socket）

进程通过叫套接字的软件接口向网络发送报文和从网络接收报文

套接字也称为应用程序和网络之间的应用程序编程接口（Application Programming Interface，API）

套接字 <-> 门户

* 发送进程将报文推出门户，发送进程依赖于传输层设施在另外一侧的  
  门将报文交付给接受进程
* 接收进程从另外一端的门户收到报文（依赖于传输层设施）



#### 应用层协议

应用协议仅仅是应用的一个组成部分

* Web应用包括：HTTP协议，web客户端，web服务器，HTML


公开协议（open）：

* 由RFC文档定义
* 允许互操作
* 如HTTP，SMTP


专用（私有）协议（dedicated）：

* 协议不公开
* 如：Skype



#### 应用层需要传输层提供什么服务

数据丢失率

* 有些应用需要100%的可靠数据传输（如文件）
* 有些（如音频）则可以容忍一定比例下的数据丢失


延迟

* 如Internet电话、交互式游戏


吞吐

* 一些应用（如多媒体）必需最小限度的吞吐，从而使应用能够有效运转
* 一些则可以充分利用可供使用的吞吐（弹性应用）


安全性

* 机密性
* 完整性
* 可认证性（鉴别）

![image](assets/image-20220809213710-3x5dilz.png)


<br />



![image](assets/image-20220809213925-gdg5tjc.png)

![image](assets/image-20220809214548-cmo8g3e.png)

![image](assets/image-20220809214615-9u21ha6.png)


有的多媒体跑在TCP之上？

有些网络防火墙会自动过滤UDP，所以必须使用TCP保证可靠性


TCP和UDP都不提供安全性，都没有加密，明文传输。


#### SSL

secure socket layer

* 在TCP上面实现，提供加密的TCP连接（应用->SSL->TCP->传输层）https就是跑在SSL之上
* 私密性
* 数据完整性
* 端到端的鉴别

详见第八章





### Web and HTTP


**URL**

```python
URL格式
Prot://user:psw@www.someSchool.edu/someDept/pic.gif:port
协议名 用户名:口令  主机名            路径名            端口
```


#### HTTP

超文本传输协议

C/S模式：

* 客户：请求、接收、显示Web对象的浏览器
* 服务器：对请求进行响应，发送对象的Web服务器



* **使用TCP协议**

  * 端口号默认为80

* **HTTP是无状态的**

  * 服务器并不维护关于客户的任何信息，并不维持连接，且不知道历史状态


请求报文的字节数相对于对象的字节数较少


非持久HTTP：

* 最多只有一个对象在TCP连接上发送（发送一个对象给客户端后就断开TCP连接,但是知道TCP确认客户已经完整地收到响应报文为止，它才会实际中断连接）
* 下载多个对象需要多个TCP连接
* HTTP/1.0使用非持久HTTP


持久HTTP：

* 多个对象可以在一个TCP连接上传输
* HTTP/1.1默认使用持久连接


#### 响应时间模型

往返时间RTT（round-trip-time）：一个小的分组从客户端到服务器，再回到客户端的时间（传输时间忽略）


响应时间：

* 一个RTT用来发起TCP连接
* 一个RTT用来HTTP请求并等待HTTP响应
* 文件传输时间


非流水方式的持久HTTP：

* 客户端只能在**收到一个响应后才能再发出**新的请求
* 每个引用对象花费一个RTT


流水方式的持久HTTP：

* HTTP/1.1 默认模式
* 客户端遇到一个引用对象就**立即**产生一个请求
* 所有引用（小）对象只花费一个RTT是可能的


#### HTTP请求报文

两种类型的HTTP报文：请求、响应

**HTTP请求报文：**

* ASCII（可读的）![image](assets/image-20220810204322-3bzr34u.png)


HEAD命令：一般是搜索引擎只需要获取描述信息，不返回请求对象

Host：主机名

User-agent：用户代理，即向服务器发送请求的浏览器类型

Connection：close  （设置为非持久连接）

Accept-language：fr   （表示用户想要得到该对象的法语版本）


通用格式：

![image](assets/image-20220810204626-l5l8oe0.png)

请求行有3个字段：方法字段、URL字段和HTTP版本字段

首部行后面还可以跟实体体（Entity Body），在使用POST方法时不为空



提交表单输入：

POST方式：向服务器提交表单信息，首部行后面（一个额外的回车之后）还有实体行

URL方式：GET方法，再URL字段后加上

```python
?wd=xx+yy+zz&cl=3

"""
参数：wd，cl
参数值：xx+yy+zz，3
"""
```


方法类型：

HTTP/1.0：

* GET
* POST
* HEAD（维护或建立索引时使用）


HTTP/1.1：

* GET，POST，HEAD
* PUT（将实体主题中的文件上载到URL字段规定的路径，维护时使用）
* DELETE（删除URL字段规定的文字，维护时使用）


#### HTTP响应报文

![image](assets/image-20220810205353-nsjeqf8.png)

Date：服务器产生并发送响应报文的日期和时间

Server：服务器版本

Last-Modified：上一次该请求被修改的时间

Content-Lenth：对象的字节数，即首部行回车之后需要读多少个字节作为Response报文的内容，帮助找到报文的范围（传输层不管报文大小，需要应用层自己维护，比如两个15K报文可能被合并为30K报文交给服务器，服务器要自己区分为两个报文）

Content-Type：对象的类型


常见报文状态码：

![image](assets/image-20220810205926-cb8ppan.png)

![image](assets/image-20220810205933-oaapqks.png)



#### cookies

RFC 6265

用户-服务器状态

大多数主要的门户网站使用cookies

具有四个组成部分：

* 1）在HTTP响应报文中有一个cookie的首部行
* 2）在HTTP请求报文含有一个cookie的首部行
* 3）在用户端系统中保留有一个cookie文件，由用户的浏览器管理
* 4）在Web站点由一个后端数据库

![image](assets/image-20220811120344-zb4xvfn.png)




#### Web缓存（Proxy代理服务器）


Web缓存器有自己的硬盘存储空间，并在存储空间中保存最近请求过的对象的副本


不访问原始服务器，就满足客户的请求

* 用户设置浏览器：通过缓存访问Web
* 浏览器将所有的HTTP请求发送给缓存

  * 在缓存中的对象缓存直接返回对象
  * 如果对象不再缓存，缓存请求原始服务器，然后再将对象返回给客户端

好处：

* 降低客户端的请求响应时间
* 大大减少一个机构内部网络与Internet接入链路上的流量，降低带宽提升的费用
* 使较弱的ICP也能够有效提供内容


缓存既是客户端又是服务器

通常缓存是由ISP安装（大学、公司、居民区ISP）

![image](assets/image-20220810212427-gie7f70.png)


t~queue~=（I/（1-I））*（L/R）

![image](assets/image-20220810213156-pe7lgzv.png) 

![image](assets/image-20220810213850-cjm562d.png)


**条件GET方法**

问题：缓存的数据可能不是最新的，服务器可能会更新数据

解决：缓存器会再HTTP请求中指定缓存拷贝的日期If-modified-since：xxx，如果modified日期有更新（即对象被修改），缓存会更新数据




### FTP*

File Transfer Protocol

ftp：RFC 959

ftp服务器：端口号为21

![image](assets/image-20220810215716-z8kpkdf.png)



* FTP客户端/服务器通过端口21联系（控制连接），并使用TCP协议
*  客户端通过控制连接获得身份确认（用户名口令明文传输）
* 客户端通过控制连接发送命令浏览远程目录
* 收到一个文件传输命令时，服务器打开一个到客户端的数据连接（服务器主动和客户端20号端口建立TCP协议的数据连接）

  * 服务器打开第二个TCP数据连接用来传输另一个文件
  * 控制连接：带外（out of band）传送
  * FTP服务器维护用户的状态信息（**有状态**）：当前路径、用户账户与控制连接对应
* 一个文件传输完成后，服务器关闭连接


![image](assets/image-20220810220633-xpr0vrp.png)

上载（puts）或下载（gets）一般是站在客户端的角度（服务器的上载就是客户端的下载）




### Email

三个主要组成部分：

* 用户代理
* 邮件服务器
* 简单邮件传输协议：SMTP（Simple Mail Transfer Protocol）
*


**用户代理**

* “邮件阅读器”，用户代理软件
* 撰写、编辑和阅读邮件
* 如Outlook、Foxmail
* 输出和输入邮件保存在服务器上


**邮件服务器**

* 输出报文队列保持待发送邮件报文
* 邮件服务器之间的SMTP协议：发送email报文

  * 客户：发送方邮件服务器
  * 服务器：接收端邮件服务器




![image](assets/image-20220810221725-4k1f3gl.png)

报文必须位7位ASCII码，即邮件内容必须都在ASCII范围内，且只能传输英文文字



![image](assets/image-20220810224011-avzbvbg.png)


![image](assets/image-20220810224413-mvkqop7.png)


![image](assets/image-20220810224709-8c0eumt.png)

首部行还有：

* CC：抄送给另一个人


**报文格式：多媒体扩展**

MIME：多媒体邮件拓展（multimedia mail extension）

在报文首部用额外的行申明MIME内容类型

![image](assets/image-20220810224950-e309rwd.png)



用户代理将邮件通过SMTP发给邮件服务器（推） -> 邮件服务器通过SMTP发送给目标邮件服务器（推） -> 用户代理再通过存取协议POP3，从邮件服务器中存储邮件（拉）

![image](assets/image-20220810225112-mez6hzf.png)

![image](assets/image-20220810225357-8mvuvzr.png)


* 下载并删除模式

* 下载并保留模式

![image](assets/image-20220810225739-lvow10y.png)


如今大部分电子邮件都是基于Web




### DNS

Domain Name System

便于机器将域名转化为IP地址


* 层次化命名，解决一个平面命名的崇明问题
* 分布式的数据库维护和响应名字查询
* 如何维护：增加或删除域名需要做什么工作


早期ARPANET用一个网站集中维护映射文件Hosts.txt，每台主机定时从维护站取文件


一个IP地址由4个字节组成，并有着严格的层次结构，每个字节用“.”隔开，表示了0-255的十进制数字



DNS的主要思路

* 分层的、基于域的命名机制
* 若干分布式的数据库完成名字到IP地址的转换
* 运行在**UDP**之上**端口号为53**的应用服务
* 核心的Internet功能，但以应用层协议实现

  * 在网络边缘处理复杂性


DNS的主要目的

* 实现主机名-IP地址的转换
* 其他目的

  * 主机别名（Host aliasing）到规范主机名（canonical hostname）的转换
  * 邮件服务器别名到邮件服务器正规名字的转换：Mail server aliasing
  * 负载均衡：Load Distribution

    * 繁忙的站点被冗余分布在多台服务器上，每台服务器均运行在不同的端系统上，每个都有着不同的IP地址。


DNS域名结构

* NDS采用层次梳妆结构的命名方法
* 每个（子）域下面可划分为若干子域（subdomains），树叶是主机
* 全世界共有13个**根DNS服务器**（标号为A到M），大部分分布在北美洲
* Internet根被划为几百个**顶级域**（Top-Lever Domains，TLD）

  * 通用的（generic）
  * .com .edu .gov .int .mil .net .org .firm .hsop .web .arts .rec
  * 国家的（countries）
  * .cn .us .nl .jp
* **权威DNS服务器**：组织机构的DNS服务器，提供组织机构服务器（如Web和mail）可访问的主机和IP之间的映射，组织机构可以选择实现自己维护或由某个服务提供商来维护



域名（Domain Name）

* 从本域网上，直到树根
* 中间使用“.”间隔不同的级别
* 域的域名：可以用于表示一个域
* 主机的域名：一个域上的一个主机


域名的管理：

* 一个域管理其下的子域
* 创建一个新的域，必须征得它所属域的同意


域与物理网络无关：

* 与遵从组织界限，而不是物理网络

  * 一个域的主机可以不在一个网络
  * 一个网络的主机不一定在一个域
* 域的划分是逻辑的，而不是物理的



一个名字服务器的问题：

* 可靠性问题：单点故障
* 扩展性问题：通信容量
* 维护问题：远距离的集中式数据库


区域（zone）

* 区域的划分由区域管理者自己决定
* 将DNS名字空间划分为互不相交的区域，每个区域都是树的一部分
* 名字服务器：

  * 每个区域都有一个名字服务器：维护着它所管辖区域的权威信息（authoritative record）
  * 名字服务器允许被放置在区域之外，以保障可靠性





资源记录（resource records）

* 作用：维护 域名-IP地址（其它）的映射关系
* 位置：Name Server的分布式数据库中


RR格式（domain_name，ttl，type，class，Value）：

* Domai_Name：域名
* ttl：time to live，生存时间（权威，缓冲记录）

  * 无限大时为权威记录，有限大时为缓存记录（缓存是为了性能，删除是为了一致性）
* Class  类别：对于Internet，值为IN
* Value  值：可以是数字，域名或ASCII串

  * 存储域名对应的IP
* Type  类型：资源记录的类型

![image](assets/image-20220811221255-7z1rpsm.png)


一台设备上网必须具备的信息：

IP地址，所在子网子网掩码，默认网关（Default Gateway），本地名字服务器（Local Name Server）


**本地名字服务器**

* 并不严格属于层次结构
* 每个ISP都有一个本地DNS服务器，也成为“默认名字服务器”
* 当一个主机发起一个DNS查询时，查询被送到其本地DNS服务器，起着代理的作用，将查询转发到层次结构中


名字解析结果：

* 目标名字在本区域内/有缓存，直接返回
* 否则顺着 根-TLD 一直找到权威名字服务器


递归查询

![image](assets/image-20220811223152-uc6nsag.png)


迭代查询

![image](assets/image-20220811223217-ri95r8c.png)

即先递归后迭代




DNS协议、报文

![image](assets/image-20220811223339-ozfz33n.png)

ID号使服务器可以并行查询多个域名

![image](assets/image-20220811223518-ukwvc45.png)


一旦名字服务器学到了一个映射，就会缓存起来，默认TTL为两天



新增一个域：要插入两条新的RR记录，一条是本服务器和权威服务器的域名，另一条是权威服务器的IP![image](assets/image-20220811223703-46tqnss.png)



攻击DNS

![image](assets/image-20220811223934-9gvkabo.png)<br />




### P2P应用

例子：

* 文件分发（BitTorrent）
* 流媒体（KanKan）
* VoIP（Skype）


传统C/S模式下载一个F大小的文件：

分发时间为：Dcs >= max{F/d~min~，NF/u~s~}  （d~min~为用户的下载带宽的最小项，N为用户数，u~s~为服务器的上载带宽）

在客户数量少时，客户的下载带宽是瓶颈，随着用户数量增加，瓶颈变为服务器的上载带宽，D~cs~随N的增加而线性增加



P2P模式下载一个F大小的文件

D~p2p~ >= max{ F/u~s~，F/d~min~，NF/（u~s~+∑u~i~）}


![image](assets/image-20220812152623-0tpzvrc.png)



#### 非结构化P2P

如果两者之间有一个TCP连接，则peer和peer之间存在一条边，peer和peer之间的边（应用层的一跳）是任意的，并不是物理链路的一条边


**集中式目录**

* 一个对等方上线时，告知中心服务器：IP地址和拥有的资源；下线时告知中心服务器
* 存在的问题：单点故障（中心服务器故障），性能瓶颈，侵犯版权


**完全分布式**

所有的节点先构建出一个overlay（覆盖网）

* 全分布式：没有中心服务器
* 开放文件共享协议
* 许多Gnutella客户端实现了Gnutella协议
* 查询泛洪：向邻居节点查询，邻居再向其邻居查询，以此遍及全网

  * 可能不断回荡：解决：①设置TTL；②记住一次查询，不再重复

![image](assets/image-20220812154736-vn2fm28.png)

随机地给X一些Pong报文的节点并作为X的邻居

X退出时，就要跟邻居Ping告知离开，邻居再跟其邻居Ping


*Gnutella在技术上有很多问题*



**混合体**

![image](assets/image-20220812155031-imr51r0.png)


通过描述检索文件

通过Hash值请求（文件上传时会计算Hash值，Hash值作为文件的唯一标识）


**一个实际的应用：BitTorrent**

* 参与一个特定文件分发的所有对等体的集合被称为一个洪流（torrent）
* 文件被分为一个个文件块（chunk）（典型长度为256KB）
* 每个洪流都有一个基础设施节点，成为追踪器（tracker）：当一个对等体加入某洪流时，它向追踪器注册自己，并周期性地同之追踪器它仍在洪流中；新加入的对等体会获得一张表，内容是该洪流一部分对等体的IP，并会与他们进行TCP连接，相互成为“邻近对等体”
* 网络中的peers发送接收文件块，相互服务
* ![image](assets/image-20220812155841-mi6n4xe.png)


每个用户都有一个bit map（用0，1）表示自己有哪些块，没有哪些块


节点定期洪流各自的map

![image](assets/image-20220812160255-kq0ebi4.png)

新用户加入时会随机从其他节点获得几个块，然后以稀缺块优先（rarest first）获取（这样会增加其他节点对其服务的概率，且均衡每个块在洪流中的副本数量）

完全没有文件——吸血鬼，拥有所有文件——种子


有限疏通：第一轮向有限个节点提供服务

优先疏通（一报还一报，tit-for-tat）：优先选择（评估）对自己提供大带宽服务的节点

优化疏通：每隔一定周期随机向其他节点发送（因为可能是一个潜在的相互服务的节点）


BT网站可以输入关键字进行匹配描述，找到Hash，下载torrent文件，其中包括跟踪服务器的信息，再由跟踪服务器（Tracking Server）告诉你一个peer列表并让你加入洪流



#### DHT（结构化）P2P

维护树状/环状的有序拓扑

将IP地址的Hash值作为唯一标识，文件内容也做Hash处理

（以环状举例）按照IP的Hash大小作为顺序首尾相接构成环，再以一定顺序文件的部分按顺序分布让节点维护（约定好的，如60-88个块给第3个节点维护）

因此，可以很快找的对应的节点且副本数量不需要很多




### 视频流化服务和CDN：上下文


**多媒体：视频**

数字化图像：像素的阵列，每个像素被若干bits表示

编码：使用图像内和图像间的冗余来降低编码的比特数

* 空间冗余（图像内）
* 时间冗余（相邻图像间）

CBR（constant bit rate）：以固定速率编码

VBR（variable bit rate）：视频编码速率随时间的变化而变化


流化服务DASH

Dynamic，Adaptive Streaming over HTTP

服务器：

* 将视频文件分割成多个块
* 每个块独立存储，编码于不同码率（8-10种）
* 告示文件（manifest file）：提供不同块的URL


客户端：

* 先获取告知文件
* 周期性地测量服务器到客户端的带宽
* 查询告示文件，在一个时刻请求一个块，HTTP头部指定字节范围

  * 如果带宽足够，选择最大码率的视频块
  * 会话种的不同时刻，可以切换请求不同的编码块（取决于当时的可用带宽）




CDN

Content Distribution Networks

*美国Akami*  *中国ChinaCache*

全网部署缓存节点，存储服务内容，就近为用户提供服务，提高用户体验

* enter deep：将CDN服务器**深入到许多接入网**

* bring home：部署在少数（10个左右）**关键位置**，如将服务器簇安装于POP符进

  * 采用租用线路将服务器簇连接起来
  * Limelight


两种加速手段

* CDN节点中存储内容的缓存
* 用户访问域名解析重定向（找到最近最快的服务器）


ICP可以找CDN运营商布置自己的内容，即内容加速服务。





### TCP套接字编程


服务器先运行，等待连接建立

①服务器进程先处于运行状态

* 创建Welcome_socket（只包含本地IP，port）
* 和本地端口捆绑(bind(Welcome_socket, sad))   *sad是struct sockaddr_in的一个服务器实例*
* 在欢迎socket上阻塞式等待接收用户的连接(Connect_socket = accept(Welcome_socket, cad))    *cad是struct sockaddr_in的一个客户端*


客户端主动和服务器建立连接

②创建客户端本地套接字(ClientSocket)

* （隐式捆绑到本地port）(自动选取空闲的端口)

* 指定服务器进程的IP地址和端口，与服务器进程连接  (Connect())


③当客户端连接请求到来时

* 服务器接收来自客户端的请求，接触阻塞式等待，返回一个新的Connect_socket（包含客户端和服务端两端的IP和port），此时客户端真正返回了一个有效的socket值,才能真正建立连接, 与客户端通信

  * 允许服务器与多个客户端通信（可以只有一个Welcome_socket，而有多个Connect_socket对应连接多个客户端）
  * 允许源IP和源端口来区分不同的客户端


④连接API调用有效时，客户端与服务器建立了TCP协议




数据结构 sockaddr_in

```C
struct sockaddr_in{
	short sin_family;  // 地址簇
	unsigned short sin_port;  // 端口号
	struct in_addr sin_addr; // IP地址,从hostent的IP地址列表中copy过来
	char sin_zero[8];  // 对齐

}
```


数据结构 hostent

```C
struct hostent{
	char *h_name;  // 主机域名
	char **h_aliases;  // 域名别名的列表
	int h_addrtype;  // 地址类型
	int h_length;   // 地址长度
	char **h_addr_list;  // IP地址的列表
	#define h_addr h_addr_list[0]
}
```


![image](assets/image-20220814163614-qlumj6e.png)




### UDP套接字编程

* 由于没有握手，除了自身的socket（只包含自己的IP和端口）以外，发送端每一个报文中必须明确指定目标的IP地址和端口

* 服务器必须从接收到的分组中提取出发送端的IP地址和端口号


无连接的PDU一般称为数据报（datagram）


服务器：

①建立ServerSocket = Socket（）

②bind（ServerSocket，sad）

③recvfrom（ServerSocket，cad）  阻塞


客户端：

④ClientSocket = Socket（）

⑤bind（ClientSocket，cad）

⑥Sendto（ClientSocket，sad）


服务器

⑦recvfrom（ServerSocket，cad）  解除阻塞

⑧内部处理

⑨Sendto（ServerSocket，cad）


客户端

read（ServerSocket）


![image](assets/image-20220814164402-iexpn77.png)






## 第三章 传输层


### 概述和传输层服务

传输服务为运行在不同主机上的应用进程提供**逻辑通信**

传输协议运行在端系统：

* 发送方：将应用层的报文分成报文段，然后传递给网络层
* 接收方：将报文段重组成报文，然后传递给应用层


有多个传输层协议可供应用选择：

* Internet（基于IP）：TCP和UDP

可靠的、保序的传输（字节流）：TCP

* 多路复用、解复用
* 拥塞控制
* 流量控制
* 建立连接

不可靠、不保序的传输（数据报）：UDP

* 多路复用、解复用
* 没有为尽力而为的IP服务添加更多的其他额外服务



网络层服务：主机之间的逻辑通信

传输层服务：进程之间的逻辑通信

* 依赖于网络层的服务

  * 无法优化的：延时、带宽
* 对网络层的服务进行优化

  * 解决数据丢失、解决顺序混乱、加密



### 多路复用与解复用

多路分解：将传输层报文段中的数据交付给正确的套接字的工作。

多路复用：在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息（用于以后的分解），从而生成报文段，然后将报文段传递到网络层。


发送方主机：多路复用

* TCP：根据socket含有的双方IP地址和端口号等信息，在【socket+数据】的头部加以封装，形成报文段
* UDP：根据socket含有的本地IP地址和端口号，以及携带到传输层的对方IP地址和端口号，在【socket+对方IP和端口+数据】的头部加以封装，形成报文段


接收方主机：多路解复用

* TCP/UDP：根据报文段头部信息中的IP地址和端口号将接收到的报文段发送给正确的套接字


![image](assets/image-20220816194900-b1lrbpd.png)


![image](assets/image-20220816194932-7cvxx9k.png)




### 无连接传输UDP

User Datagram Protocol  [RFC 768]


“尽力而为”的服务：

* 可能丢失
* 可能乱序


无连接：

* 发送端和接收端无需握手
* 每个UDP报文段都被独立处理


被用于：

* 流媒体（丢失不敏感，速率敏感、应用可控制传输速率）
* DNS
* SNMP


在UDP上可行可靠传输：

* 在应用层增加可靠性
* 应用特定的差错恢复


cost（head，头部）  payload（载荷）

应用层发送到UDP的头部只有8个字节，UDP发送到IP的头部有20个字节（都相对TCP小，因此速率快）



UDP校验和

目标：检验在被传输报文段中的差错（如比特反转）

校验和不符合时，不通过校验，会丢掉数据报

但是校验和符合时，不一定保证数据报没有差错，不能排除残存错误（*负负得正，如一增一减最后校验和不变）


发送方：

* 将报文段的内容（除去头部）视为16比特的整数（切成很多块长16比特的小部分，不足时补零凑出来）
* 校验和：报文段的加法和（1的补运算：**进位回滚**，即溢出的数字要回到最低一位重新相加）

  * ![image](assets/image-20220816200639-pjm9c75.png)
  * 校验和是和的反码（这样可以-> 相加得到全1则通过校验）


接收方：

* 计算接收到的报文段的校验和
* 检查计算出的 校验和 与 校验和字段 的内容是否相等




### 可靠数据传输的原理

* 在应用层、传输层和数据链路层都很重要，本节研讨中，采用通用术语“分组”而不是专属于运输层的“报文段”

* 是网络Top10问题之一

* *实际上有些网络的链路层就有可靠数据传递*

* 信道的不可靠特点决定了可靠数据传输协议（rdt）的复杂性


**可靠数据传输（Reliable Data Transfer Protocol）的原理**

*udt（不可靠数据传输）*

下面我们将：

* 渐增式地开发可靠数据传输协议的发送方和接收方
* 只考虑单项数据传输（但控制信息是双向流动的）
* 双向的数据问题实际上是两个单项数据传输问题的综合
* 使用有限状态机（FSM，Finite-State Machine）来描述发送方和接收方

  * 状态（用点表示）：在该状态时，下一状态只由下一个事件唯一确定
  * 状态点之间的边（箭头）上有标记，分子为引起状态变迁的事件，分母为状态变迁时采取的动作
  * 如果对一个事件没有动作/没有就事件发生而采取了一个动作，则用^表示
  * FSM的初始状态用虚线表示



#### Rdt 1.0 在可靠信道上的可靠数据传输

* 下层的信道是完全可靠的

  * 没有比特出错
  * 没有分组丢失
* 发送方和接收方的FSM

  * 发送方将数据发送到下层信道
  * 接收方从下层信道接收数据

![image](assets/image-20220817094546-ob2b3n3.png)


#### Rdt 2.0 停等协议和自动重传请求

ARQ，Automatic Repeat reQuest

* 在具有比特差错的信道可能会出错：将分组中的比特翻转

  * 用校验和（checksum）来检验比特差错
* 问题：怎样从差错中恢复

  * 发送方要保存数据的副本
  * 确认（ACK）：

    * 接收方 显式地告诉发送方分组已被正确接收
    * 发送方 收到NAK后，发送新的分组
  * 否定确认（NAK）：

    * 接收方 显式地告诉发送方分组发生了差错（corrupt）
    * 发送方 收到NAK后，会重传分组
* rdt 2.0 中的新机制：采用差错控制编码进行差错检测

  * 发送方进行 差错控制编码、缓存
  * 接收方使用编码检错
  * 接收方的反馈：控制报文（ACK，NAK）：接收方→发送方
  * 发送方**收到反馈后做相应的动作**（这种协议叫做**停止等待协议**(Stop and Wait)：发送方发送一个分组，然后等待接收方的应答）

![image](assets/image-20220817094607-8hfak7m.png)


rdt 2.0 的致命缺陷：

* 如果ACK/NAK出错，发送方不知道下一步的动作，因此需要引入新的机制
* 处理ACK/NAK出错的三种可能性：

  * 设置确认的确认，但是这样就必须再设置确认的确认的确认...
  * 增加足够的检验和比特，使发送方不仅可以检验差错，还可以恢复差错。（适用于会产生差错但不丢失分组的信道）
  * 对于出错的ACK/NAK，发送方直接重新发送（这样会出现冗余分组（duplicate data packet），接收方不知道到来的分组是旧的重传还是新的，因此需要给分组设定序号）



#### Rdt 2.1 分组序列号

新的机制：序列号：发送方在分组中加入序列号（两个序列号，0和1就够了，足以区分新旧）


发送方：

* 分组加入序列号
* 一次只发送一个未经确认的分组
* 必须检验ACK/NAK是否出错（需要EDC）
* 状态数变成两倍（因为需要记住当前分组的序列号是0还是1）


接收方：

* 必须检测接收到的分组是否重复（状态会指示希望接收到的分组的序号）
* 接收方并不知道发送方是否受到了ACK/NAK，也不会安排“确认的确认”


处理重复：

* 发送方在每个分组中加入序列号
* 如果ACK/NAK出错，发送方**重传**当前分组
* 接收方根据序号，丢弃（不发送给上层）重复分组 或者 将新的分组发送给上层 / 丢弃错误分组，并重新发送ACK / NAK，以告知发送方接收的情况

![image](assets/image-20220817095401-dejndz5.png)

![image](assets/image-20220817101021-su9ewdw.png)


举例：

发送方收到的ACK/NAK出错：

* 发送方重新发送P0
* 接收方原本发送的是ACK：接收方丢弃重复的P0，并重发ACK
* 接收方原本发送的是NAK：接收方将P0交付给上层，并发送ACK
* 如果发送方能成功接收到ACK，则发送方下一次会发送P1；否则重复上述步骤



#### Rdt 2.2 无NAK协议

* 功能同rdt 2.1，但只使用ACK（进行编号）
* 接收方对**最后**接收的分组发ACK，以替代NAK（必须显式地半酣正确接收分组的**序号**）
* 当发送方收到重复的ACK时，发送方会采取 与收到NAK相同的动作：重传当前分组
* 为后面的一次发送多个数据单位做准备

  * 一次能够发送多个
  * 每一个的应答都有ACK，NAK太麻烦
  * 使用对前一个数据单位的ACK代替本数据单位的NAK（ACK0 = NAK1，ACK1 = NAK0，这里还不是流水线模式，而是停等模式）
  * 确认信息减少一半，协议处理简单

![image](assets/image-20220817103810-a6smzf6.png)


#### Rdt 3.0 比特交替协议

新的假设：下层信道可能会丢失分组（数据或者ACK）

* 会死锁：如发送方发送P1，等待ACK1，但是P1被丢掉，而此时接收方在等待P1，不会发出ACK
* 加入新的机制：超时重传


超时重传：

* 发送方设置一个倒计时定时器，等待ACK一段合理的时间，如果超时，重传分组

  * 链路层的timeout时间确定的传输层timeout时间是适应式的，根据正态分布保证符合99%以上的情况
  * 倒计时定时器时间设置不合理，会降低效率
* 如果分组只是被延迟了而不是被丢失，此时会接收方会分组重复，而rdt 2.1 的序号机制 已经可以处理
* 发送方收到重复的ACK0（即NAK1），由于不知道此ACK0是 重传的回复刚到 还是 延迟的接收方对第一次发送分组的回复，**不会立即重传P0**，而是等倒计时定时器到了自动发送（因为如果立即发送，会重新设定倒计时定时器）
* 发送方收到重复的ACK1，则发送新的P0（即P2），并设定倒计时定时器


注：此时还没到流水线，只会一个一个发，所以用0和1序号已经足够

![image](assets/image-20220817105815-xdm5aw5.png)


问题：在信道容量大的时候，信道利用率极低，性能很差（1Gbps的链路，15ms端到端传播延时，只有一个15KB的分组对链路的利用率极低）

* U~sender~：利用率 - 忙于发送的时间比例

  * ```C
    t = 15ms
    RTT = 2t = 30ms
    L = 1KB = 1000 Bytes = 8000 Bits
    R = 1Gbps
    T = L/R = 8ms
    U = T/(T+RTT) = 0.027%
    有效吞吐 = L/t = R * U = 270kbps
    ```
  * ![image](assets/image-20220817112145-7znj490.png)
  * 而且我们还忽略了路由器上的处理时延和排队时延，这些时延将进一步降低利用率
* 瓶颈在于：网络协议限制了物理资源的利用
* 停止等待协议一般用在局域网，因为等待时间少，一次发送一个就已经利用率很高



#### 流水线协议（Pipelining）：

* 允许发送方在**未得到对方确认**的情况下，一次发送多个分组（以提高利用率，随着提高，瓶颈变为链路的带宽）
* 必须增加序号的范围：用多个bit表示分组的序号
* 在发送方/接收方要有缓冲区

  * 发送方缓冲：未得到确认，可能需要重传
  * 接收方缓存：上层用户取用速率 ≠ 接收到的数据速率：接收到的数据可能乱序，排序交付（可靠）
* 两种通用的流水线协议：回退N步（GBN，Go-Back-N）和选择重传（SR，Selective Repeat）


定义：

* 基序号（base）：最早的未确认分组的序号
* 下一个序号（nextseqnum）：最小的未使用序号，即下一个待发送的分组
* 窗口长度（N，window size）：序号范围


在实践中：

* 如果分组序号字段的比特数是k，则该序号范围是[0,2^k^-1]
* 在一个有限的序号范围内，所有涉及序号的运算必须使用模2^k^运算


滑动窗口（slide window）协议

发送缓冲区：

* 形式：内存中的一个区域，落入缓冲区的分组可以发送
* 功能：用于存放已发送，但是没有得到确认的分组
* 必要性：需要重发时可用


发送缓冲区的大小：一次最多可以发送多少个未经确认的分组

* 停止等待协议（Stop and Wait）：SenderWindow = 1
* 流水线协议：SW > 1，缓冲区大小取合理的值，不能很大，链路利用率不能够超过100%

SW = 1，RW = 1	Stop and Wait

SW > 1，RW = 1	GBN

SW > 1，RW > 1	SR（Selected Repeat）


发送缓冲区的分组：

* 未发送的：落入发送缓冲区的分组，可以连续发送出去
* 已经发送出去的、等待对方确认的分组：发送缓冲区的分组只有得到确认才能删除


发送窗口：

* 发送窗口是发送缓冲区的子集

![image](assets/image-20220817113908-beop3c9.png)


*为了便于学习*：

* 发送窗口的后沿是左边的，前沿是右边的
* 采用相对滑动的形式（分组不动，发送缓冲区前移。真实滑动为：缓冲区不动，分组移动）


发送窗口的前沿移动：

* 移动的极限：不能超过发送缓冲区

发送窗口的后沿移动：

* 得到已发送的**最旧的**分组的确认
* 发送窗口后沿向前移动
* 移动的极限：不能超过前沿


接收窗口：

接收窗口 = 接收缓冲区

* 接收窗口用于控制哪些分组可以接收：

  * 只有收到的分组序号落入接收窗口内才允许接收
  * 否则丢弃
* 接收窗口尺寸

  * W~r~=1，则只能顺序接收，接收到高序号分组会丢弃
  * W~r~>1，允许乱序接收（在一定范围内）
* 接收窗口的滑动：

  * 低序号分组到来，接收窗口后沿前移
  * 高序号分组提前到来，回复并缓存但不交付（因为要实现rdt，不允许失序），不滑动（一定要等最低序号的分组收到才能滑动）
* 发送确认：

  * 接收窗口尺寸 = 1，发送连续收到的最大的分组的确认（累计确认：cumulative acknowledge，意味着该分组之前序号的分组已经收到）
  * 接收窗口尺寸 > 1，收到分组旧发送该分组的确认（非累计确认/独立确认：并不意味着该分组之前序号的分组已经收到）


![image](assets/image-20220817144957-eevvl3l.png)

![image](assets/image-20220817145024-rrlwe87.png)




GBN和SR的不同点：

* GBN：接收窗口尺寸 = 1

  * 接收端：

    * 只能顺序接收，乱序分组直接丢弃，不管序号是更大（发送端会重发）还是更小（已经接收）
    * 累计确认
  * 发送端：

    * 只需要对最老的未确认分组设置定时器
    * 从表现看，一旦一个分组没有发送成功/超时，**即使后面的分组已经发送**，也要从未成功的分组开始，**往后所有分组重发一遍**。*回退到未发送成功/超时的分组*
* SR：接收窗口尺寸 > 1

  * 接收端：

    * 可以乱序接收，乱序分组缓存但不交付
    * 非累计确认
  * 发送端：

    * 发送方为每个未确认的分组保持一个定时器
    * 一个分组没有发送成功/超时，则发送从该分组开始往后的未得到确认的分组（**已经收到ACK的分组不重复发送**）*选择未发送成功/超时的分组重发*


优缺点：

![image](assets/image-20220817150603-a3b7goe.png)


窗口长度不能设置过小，否则可能出现以下情况：

* 窗口长度设置为3，则有0，1，2，0（5），1（6），2（7）
* 有可能使0和0（5）混淆


在基于事件编程（event-based programming）方式中，每个过程要么被协议栈中的其他过程调用，要么作为一次中断的结果。

这些过程包括：

* 来自上层实体的调用去调用rdt_send（）
* 定时器中断
* 报文到达时，来自下层的调用去调用rdt_rcv（）


在发送方和接收方由单段物理线路相连的情况下，通常信道不会对分组重新排序

但如果“信道”是一个网络时，分组重新排序可能发生。

导致一个后果：一个具有序号或者确认号x的分组的旧副本可能出现，但是x不在双方的窗口内，由于一个序号可以被重复使用，会出现一些错误。

实际应用中采用的方法是：确保一个序号不被重新使用，直到发送方“确信”任何先前发送的序号为x的分组都不再在网络中为止。（设定“存活”时间）



### ~面向连接的协议：TCP


#### 段结构

* 点对点：一个发送方，一个接收方
* 可靠的、保序的字节流：没有报文边界
* 管道化（流水线）：

  * TCP拥塞控制和流量控制设置窗口大小
  * 根据MSS（Maximum segment size，最大报文段大小，不包含TCP头部）将数据切割成片段并各自加上头部信息，确保MSS和TCP头部（通常为40个字节）不大于MTU
  * 任何一个物理网络都有MTU（Maximum transmission unit，最大传输单元） *以太网和PPP链路层协议为1500B，因此通常MSS为1460B*
  * 最后一个片段一般小于MSS
* 发送和接收缓存：因为传输速率不对等
* 全双工数据：在同一连接中数据流双向流动
* 面向连接：在数据交换之前，通过握手（交换控制报文）初始化发送方、接收方的状态变量
* 由流量量控制：发送方不会淹没接收方


![image](assets/image-20220818093916-cumekzo.png)


* 32比特的序号是**以字节为单位**编号的（而不是报文段），表示报文段首字节在字节流的编号，一般起始位为X，则下一个报文段序号为X+MSS，第N个报文段序号为X+（N-1）*MSS


* 32比特的确认号（也以字节为单位）：期望从另一方收到的**下一个字节**的序号

*如：ACK = 555，表示收到了554及之前所有的字节。（类似GBN，累计确认）*

*接收方如何处理乱序的报文段并没有规定，实践中一般是保留失序的字节，并等到缺少的字节以填补该间隙。*


* 16比特的源端口号、目的端口号、接收窗口

* 4比特的首部长度：指示了以32比特的字为单位的TCP首部长度。由于TCP选项字段的原因，TCP首部的长度是可变的。（通常，选项字段为空，所以TCP的典型长度为20字节）
* 可选与边长的选项字段
* 6比特的标志字段：ACK，RST、SYN、FIN，PSH，URG
* 16比特的紧急数据指针字段（现在已经很少使用）




TCP往返延时（RTT）和超时

TCP超时定时器设置要比RTT长：

* 太短：太早超时，不必要的重传
* 太长：对报文段丢失反映太慢，消极


在计算机局域网内，RTT概率密度分布较集中，则可以设置超时定时器为一个固定值。

但是如果是在TCP网络中传输，则应该自适应（自动更新）

估计RTT：

* SampleRTT：测量从报文段发出到收到确认的时间（如果有重传，忽略此次测量）
* SampleRTT会变化，因此估计的RTT应该比较平滑

  * 对几个最近的测量值求加权平均（**指数加权移动平均**），而不是仅用当前的SampleRTT

![image](assets/image-20220818093954-lqka789.png)

![image](assets/image-20220818094159-cwoajo8.png)

*DevRTT可以理解为标准差的加权平均*

初始的TimeoutInterval为1秒，当出现超时时，TimeoutInterval会翻倍。

一旦受到报文段并更新EstimatedRTT，就使用上面的公式计算TimeoutInterval


#### 可靠数据传输

* TCP在IP不可靠服务的基础上建立了rdt

  * 管道话的报文段（GBN和SR的结合）
  * 累计确认（GBN）
  * 单个重传定时器（对最老的报文段，GBN）
  * 接收方是否可以接受乱序报文段，没有规定
* 通过以下时间出发重传

  * 超时（直冲发最老的未确认的报文段，SR）
  * 重复的确认，即冗余ACK

    * 如：收到了ACK50后又收到了多个ACK50（接收方由于长时间没有收到P51，且受到P51之后的多个报文段，则会多次发送ACK50），则立即重传P51，而不等超时定时器（被称为**快速重传**）


首先考虑简化的TCP发送方：

* 忽略重复的确认
* 忽略流量控制和拥塞控制


![image](assets/image-20220818100536-boj2l4k.png)

![image](assets/image-20220818102215-2lv7lob.png)

not-yet-acked segments有两种情况：

* 发送窗口中无segments
* 发送窗口中所有segments都有ACK



![image](assets/image-20220818101225-lcba49v.png)

四种情况举例：

* 接收方顺序接收到y~0~，先不发ACK=y~1~，等待500ms：

  * 如果y~1~及时到来，直接发送ACK=y~2~（选择确认）
  * 如果y~1~迟到，立即发送ACK=y~1~
* 接收方乱序接收到y~1~，而y~0~还未到来（即存在gap），立即发送ACK=y~0~：

  * 如果y~0~全部到来，直接发送ACK=y~2~
  * 如果y~0~部分到来，则发送ACK=y~0~+X（介于y~0~和y~1~之间），X为到来部分的大小


快速重传

![image](assets/image-20220818102038-5r90nh7.png)

![image](assets/image-20220818102238-nq1n31o.png)



#### 流量控制

防止发送方发送速率大于接收方的处理速率，导致接收方的缓冲区溢出

**捎带**：数据的确认承载在另一份发送数据的报文段中。

ACK和空闲缓冲区大小（Receive Window，rwnd）一起发送给对方

rwnd会放在报文段的接收窗口字段中

![image](assets/image-20220818102818-4bejgoa.png)

![image](assets/image-20220818102953-e9a6cgp.png)

假设B的rwnd为0，且A已经收到了这个报文段，于是没有再发送数据给B

而B随着时间已经让rwnd越来越大了，但是由于没有新的数据接收需要发送确认，也没有数据需要发送给A，于是rwnd的信息并不能传递给A。

为了解决这个问题，TCP这样**规定**：当主机B的接收窗口为0时，主机A继续发送只有一个字节的数据报文段。这些报文段将会被接收方确认。最终缓存将开始清空，并且确认报文里将包含一个非0的rwnd值。


*UDP并不提供流量控制，报文段由于缓存溢出可能在接收方丢失。*



#### 连接管理

**建立连接**

在正式交换数据之前，发送方和接收方握手建立通信关系：

* 同意建立连接（每一方都知道对方愿意建立连接）(准备资源）
* 同意连接参数（双方各自的初始序号，缓冲区大小等）

  * ![image](assets/image-20220818103214-76by9no.png)


2次握手的失败场景：

* 建立了半连接（只有服务器在维护连接，占用资源）

![image](assets/image-20220818105524-z13piqd.png)

由于发送方第一次请求的确认延时到来，导致提前发送了第二次请求，这个请求会让接收方建立连接，但由于发送方收到了第一次请求的确认，发送方不再维护第二次请求的连接，所以在该连接上之后没有其他动作，于是接收方维护了一条无效的连接。


* 老数据的重发被当作半连接的数据接收

![image](assets/image-20220818105805-ygc4dv5.png)

在半连接（假设为连接2）的情况下，发送方在连接1上发送P0数据，但还未收到数据接收确认，于是重新发送P0，该P0被当作连接2的数据接收了（请求连接建立的重发和P0的重发构成了一个新的无效连接）




TCP 3次握手

* 第一次握手：客户端发出特殊报文，该报文段没有应用层数据，但在首部的SYN比特设置为1，且随机选择一个初始序号（client_isn）

  * *发送方：我发送的数据 从X序号（随机选择的）开始*
* 第二次握手：服务器收到含有SYN的报文，分配TCP缓存和变量，并向该客户TCP发送允许连接的报文段，其中也有SYN，client_isn+1，自己的初始序号server_isn。这个报文段称为SYNACK报文段

  * *接收方：我收到从X序号开始（ACK=X+1）*
  * *接收方：我发送的数据 从Y序号开始*
* 第三次握手：客户端收到SYNACK报文段，分配TCP缓存和变量，在发送另一个报文段，附带server_isn+1，但SYN设置为0

  * *发送方：我收到从Y序号开始（ACK=Y+1）*
  * 第三次交互通常承载**有效载荷**，即附带数据一起发送

![image](assets/image-20220818111031-k6bmmad.png)

![image](assets/image-20220818111124-zk9y5un.png)


解决半连接：

由于接收方没有收到第三次握手，所以不会建立半连接

解决老数据的影响：

由于没有建立半连接，所以对于凭空出现的报文段会抛弃

![image](assets/image-20220818111006-amcj0eg.png)



新问题：老的连接上的数据对新的连接的一些干扰

假设双方建立连接并进行了一些有效的通信，一段时间后双方友好地断开了连接。但是这次连接中其中有一个报文段被滞留在网络中很长时间（设为Px）。

然后双方在相同端口又建立了连接，此时接收方收到了被滞留的Px，并把它当作新的数据（由于两次连接规定的序号是固定值，有可能序号恰好符合），这样就造成了影响。

解决方法：连接规定的序号采用随机方法（有32个比特），可以和时间周期相关联，这样由于比特较长，一个周期可以很长，序号恰好符合的概率可以减少到可以忽略的程度。



**关闭连接**

![image](assets/image-20220818112129-xd6cyk6.png)

报文段首部的FIN比特设置为1

分成2个半连接的关闭：（**四次挥手**）

* 发送方的半连接：

  * 发送方：我要关闭连接了
  * 接收方：好
* 接收方的半连接：

  * 接收方：我要关闭连接了
  * 发送方：好


但是这样会出现“两军问题”：不知道对方是否收到了我要关闭连接的请求，但是如果对方再发出已经收到的确认，就会陷入需要确认的确认的循环中。

不完美的解决方案：如果发送方收到接收方的关闭连接请求/接收方发送关闭连接请求之后，一段时间内对方没有再发送数据，则发送方/接收方可以关闭连接

客户端接收服务器的FIN，并发送ACK，然后进入TIME_WAIT状态，一般等待2个MSL后关闭连接

![image](assets/image-20220818151954-a0sf0w3.png)

![image](assets/image-20220818152018-7r67nj6.png)



### 拥塞控制原理

TOP10问题之一

“太多的数据通过网络传输，超过了**网络**的处理能力”，与流量控制不同

分组重传用来对付丢包，却加重了网络拥塞，因为有太多的源想以过高的速率发送数据


拥塞表现：

* 分组丢失（路由器缓冲器溢出）
* 分组经历比较长的延迟（在路由器的队列中排队）


场景1：路由器无限大的缓冲

![image](assets/image-20220819085348-iaaubn8.png)

λ~in~：发送端向网络中注入数据的速率

λ~out~：接收端从网络中接收数据的速率

分组的到达速率接近链路容量时，分组经历巨大的排队时延


场景2：路由器有限的缓冲

![image](assets/image-20220819090444-59yphw9.png)

λ~in~' （网络的供给载荷，offered load）= λ~in~ + λ~重传~


场景2的第一种情况：发送端知道路由器的空闲缓冲大小

![image](assets/image-20220819090534-r9x3d7h.png)

由于数据不会丢失，所以没有重传，则：λ~重传~ = 0，所以λ~in~' = λ~in~

然而发送端不可能知道网络中路由器的空闲缓冲


场景2的第二种情况：发送端掌握了丢失信息

![image](assets/image-20220819090704-2sd4m2w.png)

![image](assets/image-20220819091333-nix7qvk.png)

超时重传的比例越多，有效发送到接收端（不需要重传）的比例越少：

* 重传的丢失分组
* 没有必要重传的重复分组

发送方必须执行重传以补偿因为缓存溢出而丢弃（丢失）的分组


分组延迟过高，则发送方启动重发，于是重复发送分组，加剧拥塞程度，最后出现死锁

![image](assets/image-20220819091508-929g22a.png)


拥塞的“代价”：

* 分组的到达速率接近链路容量时，分组经历巨大的排队时延
* 为了达到一个有效输出，发送方必须执行重传以补偿因为缓存溢出而丢弃（丢失）的分组
* 没有必要的重传，使路由器转发了不必要的分组副本，降低了有效利用率，加剧拥塞情况


场景3：多个发送接收端共用一个网络

![image](assets/image-20220819091905-eqlk3f7.png)

拥塞状态下，一旦有空闲的缓冲区，立即被填满（根据供给载荷竞争所得），其他分组就会被抛弃，上游的传输能力就被浪费了：最终导致没有分组传达



拥塞控制方法

既要避免拥塞，又要在未拥塞时提高数据传输速率

* 端到端拥塞控制：

  * 没有来自网络的显式反馈
  * 端系统根据延迟和丢失事件推断是否有拥塞、
  * *TCP采用的方法*

* 网络辅助的拥塞控制：

  * 直接网络反馈：路由器直接发给发送端系统以反馈信息（阻塞分组，choke packet）
  * 经由接收方的网络反馈（更为通用）：标记或更新分组中的某个字段，然后让接收方向发送方通知网络拥塞指示

    * 单个bit置位，显示有拥塞（SNA，DECbit，TCP/IP ECN，ATM）
    * 显式提供发送端可以采用的速率
    * 至少需要经过一个完整的往返时间


案例学习：ATM（Asynchronous Transfer Mode，异步传输模式） ABR 拥塞控制

![image](assets/image-20220819093218-bbtcg2f.png)

![image](assets/image-20220819093243-m3kttuj.png)

信元53字节，比1比特大，比一个分组小

信元在经过路由器时，路由器会根据拥塞程度在信源的相关bit置位，接收方因此可以得知拥塞情况，而回传时也会附带这样的信息，于是发送方也能知道网络的拥塞情况。

ER字节在经过一个路由器时就会比较当前可支持速率是否小于ER字节上设定的速率，如果小于，则将ER字节上的速率设定为当前可支持速率（瓶颈速率），以此告诉端系统可以传输数据的最大速率，避免拥塞发生。

*银行的ATM机就是指使用这种模式的机器。*



### ~TCP拥塞控制

* 端到端的拥塞控制机制

  * 路由器不向主机提供有关拥塞的反馈信息

    * 路由器的负担较轻
    * 符合网络核心简单的TCP/IP架构原则
  * 端系统根据自身得到的信息，判断是否发生拥塞，从而采取动作


* 拥塞控制的几个问题：

  * 如何检测拥塞

    * 轻微拥塞
    * 拥塞
  * 控制策略

    * 在轻微拥塞/拥塞时如何动作，降低速率
    * 在拥塞缓解时如何动作，增加速率

定义：丢包事件：出现超时或受到3个冗余ACK


发送端如何检测拥塞：

* 某个段超时（丢失事件）：**拥塞**

  * 超时时间到，某个段的确认没有来
  * 原因1：网络拥塞（某个路由器缓冲区没空间，被丢弃）（**概率大**）
  * 原因2：出错被丢弃（段在传输过程中受到干扰引发各种错误，没有通过校验，被丢弃）（**概率小**）
  * 一旦超时，被认为拥塞了，有一定误判，但是总体控制方向是对的。

* 3个冗余ACK：**轻微拥塞**


如何控制发送端发送的速率：

CongWin：cwnd，拥塞窗口

RTT：往返时间

MSS：最大报文段大小

SS：慢启动阶段，slow-start（速率慢，但加速度大）

CA：拥塞避免阶段，congestion-avoidance

Threshold：警戒值/阈值

![image](assets/image-20220819104016-558djy1.png)

![image](assets/image-20220819104316-6seqql5.png)



* CongWin初始值设置为1MSS，（只要不超时/收到3个冗余ACK）每接收到一个ACK就增加一个MSS，因此每经过一个RTT就会CongWin就会翻倍

  * ![image](assets/image-20220819110634-v4nomm1.png)
* AIMD（线性增（+1），乘性减（*0.5））：

  * ![image](assets/image-20220819111118-8e0l34a.png)
  * ![image](assets/image-20220819111227-ocewl5f.png)


总结：

![image](assets/image-20220819111342-626i60p.png)

![image](assets/image-20220819111400-zmvpj82.png)![image](assets/image-20220819111800-d7ph1e6.png)

*注意：*

* *一旦超时，就要令CongWin = MSS，进入慢启动阶段*

* *快速恢复阶段不是TCP必须要求的，在旧版本中，一旦出现丢包事件，就让CongWin减到1个MSS，**并进入慢启动阶段。*
* 在含有快速恢复阶段的新版本中：

  * 在收到三个冗余ACK时，Threshold = CongWin/2，但是CongWin = <u>Threshold+3</u>！并进入快速恢复阶段
  * *在快速恢复阶段（fast recovery），接收到冗余ACK时，CongWin = CongWin + MSS，相当于慢启动阶段的指数增长*，*一旦收到新的ACK，就令CongWin = Treshold，重新进入拥塞避免状态*



联合控制的方法：

SendWin = min{CongWin（cwnd），RecvWin（rwnd）}

同时满足 拥塞控制和流量控制 的要求


TCP吞吐量

发生丢包事件时窗口大小为W，则下一时刻变为W/2，然后不断增加

可以视为在[W/2，W]之间变化

平均窗口尺寸 = [ W+（W/2) ] / 2 = (3/4)W

![image](assets/image-20220819111837-txwnixv.png)

![image](assets/image-20220819151055-1jsfqfn.png)

*注：其中L为丢包率*


TCP的公平性

![image](assets/image-20220819113627-v4vpfxw.png)

![image](assets/image-20220819113644-er6152g.png)

* x轴和y轴是两对主机分别的CongWin，蓝线是X+Y=R
* 忽略慢启动阶段
* 当没有出现拥塞时，X和Y都线性增加，于是图中成45°向上移动
* 越过蓝线一段距离后（由于路由器有缓存，所以可以X+Y短暂超过R），出现丢失事件，于是X和Y各自变为一半（状态点变更为：当前状态点与原点连线的中点）
* 经过多次变换，最终会收敛到虚线位置，也就是两对主机均用带宽


![image](assets/image-20220819114157-n8t4gx3.png)

* UDP不会抑制数据传输速率，所以对于TCP来说具有“侵略性”
* 公平性是相对的：

  * 公平性是相对于TCP来说的，而不是相对于主机来说的，比如一个主机对可以占有9条TCP连接，另外一个主机对只占有1条TCP连接，前者主机对可以占有十分之九的带宽
  * 如果一个主机对通信的延迟比较低（RTT比较小），那么它慢启动阶段持续时间比另一对久，则图中不呈45°向上，而是会有一定的角度偏差，这样最终收敛的虚线也有一定角度偏差，也就是RTT小的一方会占用多一点的带宽


![image](assets/image-20220819114718-xco3osh.png)

最近的IP和TCP也能选择性地实现网络辅助拥塞控制，即明确拥塞通告（Explicit Congestion Notification，ECN）

在网络层中，IP数据报首部的服务类型字段中的两个比特被用于ECN。

路由器会设置ECN作为拥塞指示，则TCP接收方会在TCP ACK中设定ECN告知发送方，发送方就会让cwnd减半。


数据报拥塞控制协议（Datagram Congestion Control Protocol，DCCP），类似于UDP的不可靠服务，但是拥塞控制与TCP兼容。

谷歌Chromium浏览器实现了QUIC（Quick UDP Internet Connections）协议，该协议通过重传以及差错检验、快速连接建立和基于速率的拥塞控制算法提供可靠性。（TCP友好性）

DCTCP（数据中心TCP），使用ECN以更好的支持短流和长流的混合流，这种混合流代表了数据中心负载的特征。

流控制传输协议（SCTP），TCP友好速率控制协议（TFRC）……



应用层和传输层属于网络边缘，接下来的层次则属于网络核心。



## 第四章 网络层：数据平面


### 导论


网络层服务

* 在发送主机和接收主机对之间传送**段**（segment），在发送端将段封装到**数据报**（datagram）中，在接收端解封装并将段上交给传输层
* 网络层协议存在于**每一个**主机和路由器


网络层的功能

* 转发（forwarding）（数据平面的功能）：将分组从路由器的输入接口转发到合适的输出接口
* 路由（routing）（控制平面的功能）：使用路由算法来决定分组从发送主机到目标接收主机的路径（规划路线）



数据平面：

* 本地，每个路由器功能
* 决定从路由器输入端口到达的分组如何转发到输出端口
* 转发功能：

  * 传统方式：基于目标地址+转发表
  * SDN方式：基于多个字段+流表


控制平面：

* 网络范围内的逻辑
* 决定数据报如何在路由器之间路由，决定数据报从源到目标之际之间的端到端路径
* 2个控制平面方法：

  * 传统的路由算法：在路由器中被实现
  * software-defined networking（SDN）：在远程服务器中实现


网络服务模型：

* 对于单个数据报的服务：

  * 可靠传输
  * 延迟保证，如：少于40ms的延迟
* 对于数据流的服务

  * 保序数据报传送
  * 保证流的最小带宽
  * 分组之间的延迟差


连接建立（IP网络中没有这个功能）

* 在某些网络架构中（如ATM，frame relay，X.25）是第三个重要的功能
* 在分组传输之前，在两个主机之间，在通过一些路由器所构成的路径上建立一个网络层连接（涉及路由器）
* 网络层和传输层连接服务区别：

  * 网络层（有连接）：在2个主机之间，涉及到路径上的一些路由器
  * 传输层（面向连接）：在2个进程之间，很可能只体现在端系统上（TCP连接）


<br />

![image](assets/image-20220823104606-t86vhen.png)

*Internet这种很多功能都无法保证的服务模型被称为“尽力而为”模型（一种委婉说法，其实什么都不能保证）*



### 路由器组成


![image](assets/image-20220823135755-gf24ked.png)

*绿色方框表示物理层数据，蓝色方框表示链路层数据，红色方框表示网络层数据*

*ports指端口（与套接字端口不同意思）*：*路由器的输出端口和输入端口实际成对出现在一条双向链路的线路卡上*

输入端口：具有查找功能以决定本地输出端口（传统模式下借助路由表）

*fabric为路由器的交换结构*：

*routing proceeor为路由器选择处理器：*

* 传统模式中，各个路由器独立计算路由表（分布式），僵化，不可编程
* SDN模式中，由网络操作系统计算流表（集中式）并通过南向接口交给路由器，可编程


路由器的输入端口、输出端口和交换结构几乎总是用硬件实现，而路由性选择处理器通常由软件实现（传统CPU）。




#### 输入端口

*转发表由路由器选择处理器计算和更新或来自远程SDN控制器*

基于目的地址交换到输出端口

* 在32比特IP地址下，转发表通过匹配IP地址的前缀来选择相应的链路接口转发分组
* 如：![image](assets/image-20220823144915-hn3mwqr.png)
* 如果一个目标地址和多个表项相匹配，则使用**最长前缀匹配规则**，即选择最长匹配项对应的链路接口

* “匹配加动作”抽象的特定情况不仅用在路由器中，还有许多网络设备也如此执行，例如链路层的交换机。
* 其他（default）：一般连接着网络的出口


通用交换：

* 基于头部字段的任意集合进行转发


缓存：

* 一旦通过查找确定了某分组的输出端口，改分组就能够发送进入交换结构（某些设计中，如果其他分组正在使用该交换结构，则需要暂时阻塞，并排队）

* 如果缓存溢出则会丢失分组



#### 交换

如果有N个输入端口，则交换结构的交换速度必须不小于输入线路速度的N倍

交换有许多种方式

* ![image](assets/image-20220823150510-lwqjffc.png)
* ![image](assets/image-20220823150532-pa0r3na.png)
* ![image](assets/image-20220823150552-8ymfiav.png)


#### 排队

输入排队：

* **线路前部**（Head-Of-the-Line，HOL）**阻塞**：当两个不同的输入端口同时有分组要交给相同的输出端口时，交换结构只能允许一个先通过，而另一个则需要等待，且其后的分组也要等待（无竞争：即使不是发给同一个输出端口）

输出排队：

* 多个分组同时到达输出端口，由于输出端口在一个单位时间内仅能传输一个分组，因此其后的分组需要等待
* 当没有足够的内存来缓存一个入分组时：

  * 要么丢弃到达的分组（弃尾）
  * 要么删除一个或多个已排队的分组为新来的分组腾出空间


#### 分组调度

* 先进先出（First-In-First-Out，FIFO）
* 优先权排队：某些分组（例如流媒体）优先排队，同一优先级则按照FIFO
* 循环公平排队：轮流为一类分组服务
* 加权公平排队：分组根据加权值享有部分带宽



### IP


#### IPv4数据报格式

![image](assets/image-20220825164205-cwy8ct0.png)

* 第一行（每行4个字节）：

  * 4比特的**版本号**：IPv4或者IPv6
  * 4比特的**首部长度**：用来确定数据报中被封装的运输层报文段实际开始的地方（大多数IP数据报不包含选项，所以一般的IP数据报具有20字节的首部，即图中的5行）
  * 8比特的**数据类型**：用来区分优先程度，现在已经被弃用
  * 16比特的**数据报长度**：表示IP数据报的总长度（首部加数据），单位为字节；由于只有16比特，所以IP数据报的理论最大长度为65535字节，不过很少有超过1500字节的（IP数据报能容纳最大长度以太帧的载荷字段为1500字节）
* 第二行：分片用的字段，包括：**标识**（identifier），**标志**（flag），**片偏移**（fragment offset）。flag为1时表示后面还有新的分片，为0时表示已经没有新的分片。
* 第三行：

  * 8比特的**Time-To-Live**，TTL：确保数据不会永远在网络中循环，每当一台路由器处理数据报时，该字段的值减1，若字段减为0，则路由器丢弃数据报。（路由器丢弃掉分组后会向源主机发送ICMP的错误报告）
  * 8比特的**协议**（传输层）：值6表示TCP，值17表示UDP

    * 协议号的作用（绑定网络层与运输层）类似于传输层的端口号（绑定运输层与应用层）
  * 16比特的**首部检验和**：

    * 用于校验首部信息，而TCP的校验和用于校验整个TCP报文段
    * 计算方法同运输层
    * 但是每台路由器必须重新计算检验和并再次存放到原处，因为TTL字段以及可能的选项字段会改变
* 第四行：32比特的**源IP地址**
* 第五行：32比特的**目的IP地址**
* 第六行：可能的**选项**（第六行及之前为IP数据报的首部）
* 第七行之后：数据

<u>假设无选项</u>，一个IP数据报的首部有20个字节，加上TCP的报文段有20个字节，则IP数据报为40个字节+应用层报文。



#### 分片和重组（Fragmentation & Reassembly）

> 一个链路层帧能承载的最大数据量叫作**最大传送单元**（Maximum Transmission Unit，MTU）
>

并不是所有链路层协议都能承载相同长度的网络层分组，例如：以太网帧能够承载不超过1500字节的数据，而某些广域网链路的帧可承载不超过576字节的数据。

因此需要对IP数据报进行 分**片**（fragment），片在其到达目的地的端系统时才会进行重组，而不是在网络路由器。


* 发送主机通常会在发送每个数据报时，令它的**标识号**（identifier）加1。当某个路由器对一个数据报分片时，该片具有相同的源地址、目标地址和标识号。
* 一个数据报的最后一个片的**标志**（flag）设置为0，其余的片的标志设置为1
* 使用**偏移字段**（fragment offset）指定该片应放在初始IP数据报的哪个位置（第几个字节）。


#### IPv4编址

> 主机与物理链路之间的边界叫作**接口**（interface）
>

IP地址用来标识网络设备的<u>接口</u>，而不是一台主机/路由器。

由于路由器必须拥有两条以上链路与它连接，才能对数据进行转发，所以一个路由器一定得有两个以上的IP地址。


每个IP地址长度为32比特，所以总共有2^32^个可能的IP地址，这些IP地址用**点分十进制记法**进行书写，即每个字节用它对应的十进制表示，各个字节间用句号（.）隔开。

一个接口的IP地址的一部分需要由其连接的子网决定。


子网（Subnets）

* 子网是隔离的网络岛
* 一个子网内的节点的IP前缀相同（前3个字节）
* 无需路由器介入（可能借助交换机），一跳可达

![image](assets/image-20220825202552-t20xyqw.png)


> **子网掩码**（network mask）用来表示一个IP地址中前若干位表示子网地址，如：223.1.1.0/24表示前24位的223.1.1.x表示子网地址，后面的8位为主机地址
>


![image](assets/image-20220825203615-n2zn35w.png)

*图中有3台路由器但有6个子网*

如果把R1上面的两台计算机记为N1，R2下面的记为N2，R3下面的记为N3，则有以下6个子网：

1. N1（223.1.1.0/24）
2. N2（223.1.2.0/24）
3. N3（223.1.3.0/24）
4. N1，N2（223.1.9.0/24）
5. N2，N3（223.1.8.0/24）
6. N1，N3（223.1.7.0/24）

甚至可以**聚合**N1，N2，N3的**路由**信息为一条向外发布

> 因特网的地址分配策略被称为**无类别域间路由选择**（Classless Interdomain Routing，CIDR）：a.b.c.d/x中，x指示了第一部分的比特数，即前缀（prefix），表示IP地址的网络部分（对应一个子网）；也可以用32个比特来表示。一个组织通常被分配一块连续的地址，具有相同的前缀，而前缀之后则为主机部分。CIDR有利于路由选择。
>

以子网为单位向外散播子网可达信息，减少计算量和路由通讯代价。

长途链路一般为点到点传输，而局域网一般通过交换机间接连接。

> 使用单个网络前缀通告多个网络的能力称为**地址聚合**（address aggregation）或**路由聚合**（route aggregation）或**路由摘要**（route summarization）
>

![image](assets/image-20220825214923-8p1cbdo.png)

组织0到7的IP地址前20位相同，因此ISP通告互联网将前缀（20位）为200.23.16.0/20的信息的发送给它。也就是说ISP是组织0到7的下一跳。


![image](assets/image-20220825215404-ms8mrkj.png)

前缀不同时不能聚集。

路由聚集支持<u>有空洞</u>的聚集（比如一个连续段中的一部分被其他ISP收购），以减少通告和路由信息表项的数量以及计算代价。如图中这种情况要使用**最长前缀匹配**（最精确）。


在CIDR以前，采用分类编址。

分类编址：IP地址的网络部分长度限制为8、16或24比特。

![image](assets/image-20220825205205-5yi0t82.png)

* A、B、C类地址为单播地址；D类地址为组播/广播地址


**特殊IP地址**

* 子网部分 位全0的地址（本网络地址）用于表示本子网
* 主机部分 位全0的地址表示本主机
* 主机部分 位全1的地址（广播地址）用于表示本子网中的所有主机
* 127.x.x.x：回路地址/测试地址
* 内网地址：（不会被当作公用地址来分配）

  * A类：10.0.0.0-10.255.255.255         MASK 255.0.0.0
  * B类：172.16.0.0-172.31.255.255     MASK 255.255.0.0
  * C类：192.168.0.0-192.168.255.255 MASK 255.255.255.0


路由信息的匹配：

* 路由表具有以下信息，共4个表项：目标子网地址，子网掩码，下一跳（Next hop），接口（Interface）
* 先将目标子网地址和子网掩码进行**与**运算，得到子网地址
* 然后在转发表上进行匹配（最长前缀匹配）并转发


如何获得一个地址块：

由ICANN机构权威分配地址，该机构还负责管理DNS，分配域名解决冲突。


如何获得一个子网：

从地址块中请求一个小地址块

让大地址块前缀之后的若干位与大地址块的前缀构成新地址块的前缀，也就是申请到了子网的子网。


如何获得一个IP地址：

* 系统管理员将地址配置在一个文件中
* DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）：从服务器中动态获得一个IP地址

  * ![image](assets/image-20220825212719-y2xcqas.png)
  * ![image](assets/image-20220825213115-uvtg4tt.png)
  * 两次握手（主机第一次广播，第二次单播）是因为可能有多个DHCP server为主机提供**IP地址**、**子网掩码**、**默认网关**（第一跳路由器地址）、**DNS服务器**，可以由主机从中确认选择一套


#### 网络地址转换

Network Address Translation，NAT

内网设置的IP对互联网无意义。

![image](assets/image-20220825230216-kxnzzce.png)

![image](assets/image-20220825230236-43cpy1t.png)

即用外网IP的端口代表内网的某个ip的端口

![image](assets/image-20220825230327-77i3l1d.png)

![image](assets/image-20220825230352-5s20drt.png)

NAT穿越问题

![image](assets/image-20220825231050-peeysiu.png)

![image](assets/image-20220825231136-mnpslha.png)

![image](assets/image-20220825231228-4bx8paj.png)



#### IPv6

初始动机：32bits地址空间将会被分配完

其他动机：

* IPv4头部会不断改变，应该让头部格式改变帮助加速处理和转发
* 头部格式改变帮助QoS（quality of Severs）


数据报特点：

* 地址增加到128比特，同时增加新型地址**任播地址**（anycasst address），表示可以把数据报交付给一组主机中的任意一个。
* 固定的40字节头部（删除**选项**）
* 流标签：（仍未完全确定）视频与音频传输可能当作流，具有较高的优先级，而文件传输和电子邮件则不可能当作流。
* 数据报传输过程中，不允许分片

![image](assets/image-20220825231743-waoxhl4.png)

hop limit与TTL类似

数据报格式：

* 第一行：

  * 4比特的**版本**
  * 8比特的**流量类型**
  * 20比特的**流标签**
* 第二行：

  * 16比特的**有效载荷长度**
  * 8比特的**下一个首部**（下一个数据报交付给哪个上层实体，TCP/UDP/选项）
  * 8比特的**跳限制**：类似于TTL
* 第三行：128比特的**源地址**
* 第四行：128比特的**目的地址**
* 第五行之后：数据


有几个IPv4的字段已经不存在：

* 分片/重新组装

  * 接收过大数据报会丢弃并向源主机发送ICMP错误报告“Packet Too Big”
  * *霸道地让源主机不要发送过大的数据报*
  * 加快了数据报的传输
* 首部检验和

  * 由于传输层和数据链路层协议执行了检验操作，网络层的检验显得多余
  * 加快了数据报的传输
* 选项

  * 实际上并没有完全消失，而是可能出现在IPv6首部中由“下一个首部”指出的位置上（即选项字段也能是下一个首部，而不是仅仅可能为TCP/UDP）

![image](assets/image-20220825231816-lrz44ta.png)


#### 从IPv4到IPv6的迁移

用户数量庞大，无法约定标志日同时宕机升级。

*网络层的改变比应用层难得多、慢得多*

建隧道（tunneling）：IPv6的网络边缘的路由器将整个IPv6的数据报封装在IPv4的数据报的数据部分，然后通过IPv4路由器传输到另一个IPv6的网络边缘然后解封装（观察在IPv4数据报中的协议号字段为41，指示该IPv4数据报的有效载荷是IPv6数据报）

当大部分网络升级为IPv6后，则反过来：把IPv4的数据报封装在IPv6的数据报的数据部分。



### 通用转发和SDN


![image](assets/image-20220826110857-pqa9ndf.png)

![image](assets/image-20220826110916-a2la9dn.png)

![image](assets/image-20220826110928-1oovx25.png)

![image](assets/image-20220826111440-5ml22lq.png)

代理将流表通过南向接口发到分组交换机中，后者按照流表的表项匹配做出动作（包括转发、阻塞、丢弃、泛洪等）

![image](assets/image-20220826111900-tw22mai.png)

![image](assets/image-20220826111919-6v6pf88.png)

![image](assets/image-20220826112850-tnqmtvf.png)

![image](assets/image-20220826112859-6pq4h14.png)

![image](assets/image-20220826112911-bp6597e.png)

![image](assets/image-20220826112926-3notual.png)

可以实现多种功能，由于可编程，一次部署可以多次升级


![image](assets/image-20220826113548-eck9zvd.png)


例子：

![image](assets/image-20220826113607-l82fcou.png)

![image](assets/image-20220826113618-adwnsns.png)

![image](assets/image-20220826113637-pdwkepw.png)
